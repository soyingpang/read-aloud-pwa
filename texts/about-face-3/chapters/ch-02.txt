第二章

 實作模型與心智模型（Implementation Models and Mental Models）

電腦產業常常使用「電腦素養（computer literacy）」這個詞。評論者會談：有些人有、有些人沒有；有電腦素養的人會在資訊經濟中成功；缺乏的人就會不可避免地掉進社經落差的裂縫裡。但其實，「電腦素養」不過是一個委婉說法：它等於在逼人類去拉伸自己的思考方式，好理解一套陌生的機器邏輯，而不是讓軟體產品去伸展、去符合人們原本的思考方式。本章會討論：對使用者以及他們如何接近數位產品的方式理解不足，如何加劇了「電腦素養」的鴻溝；以及更貼近人們思考與工作方式的軟體，如何能幫助解決這個問題。



 實作模型（Implementation Models）

任何機器都有一套機制來達成它的目的。以電影放映機為例，它用一連串複雜而精密運動的零件來製造影像的幻覺。它會把非常亮的光穿過一張半透明的小小底片影像，照射短短一瞬間；接著在移動下一張底片影像就位的那一瞬間，把光遮住；然後再放開光照一瞬間。它用新的影像每秒重複這個流程 24 次。

靠軟體驅動的產品，沒有這種「會動的零件」意義上的機械結構；它們用的是演算法與程式碼模組，並且彼此溝通。Donald Norman 等人把「機器或程式實際怎麼運作」的表述稱為 system model；我們更偏好稱它為實作模型（implementation model），因為它描述的是程式在程式碼層面如何被實作出來的細節。



 使用者的心智模型（User Mental Models）

站在看電影的觀眾角度，當你沉浸在精彩劇情時，很容易忘掉那些齒孔、遮光機構之類的細節。其實，很多觀眾根本不知道放映機到底怎麼運作，也不知道它跟電視運作方式有何不同。觀眾會想像：放映機只是把會動的畫面投到大螢幕上。這就叫做使用者的心智模型（mental model），或概念模型（conceptual model）。

人們不需要知道複雜機構的所有真實細節，也能使用它。所以他們會建立一種「認知捷徑」來解釋它：這個解釋足夠強，可以支撐自己跟它互動，但不一定反映它內部真正的機械運作。比如很多人會想像：把吸塵器或果汁機插到牆上的插座時，電就像水一樣，從牆裡沿著電線那條小黑管「流」到家電裡。這個心智模型對使用家電來說完全夠用。至於家庭用電的實作模型其實完全不像液體在電線裡流動，而且電位每秒反轉 120 次——這些對使用者都無關緊要，但電力公司需要知道。

不過在數位世界裡，使用者心智模型跟實作模型之間的差異常常非常明顯。比如我們通常不會管：行動電話其實不像市話；它本質上是一個無線電收發器，一通兩分鐘的電話裡可能在半打不同基地台之間切換連線。知道這些，也不會讓我們更懂得怎麼用手機。

在軟體應用程式上，實作模型與心智模型的落差尤其巨大：實作的複雜度往往讓使用者幾乎不可能看出「我做了什麼」與「程式做了什麼反應」之間的機械式對應關係。當我們用電腦做數位音訊編輯、或做像 morphing 這種影片特效時，我們幾乎找不到對應到機械世界的類比，因此心智模型必然與實作模型不同。就算那些連結真的能被看見，對大多數人來說也依然難以理解。



 被呈現的模型（Represented Models）

軟體（以及任何依賴軟體的數位產品）都有一張「行為的臉」面向世界——那是由程式設計師或設計師創造出來的。這個呈現不一定忠實描述電腦內部真正發生的事，雖然很不幸地，它經常就是如此。相較於其他媒介，軟體更能做到：在不改變真實運作的前提下，改變它「如何被解釋」給使用者。聰明的設計師可以把一些軟體「其實很難看」的內部做法藏起來。

這種「實作」與「對外解釋」之間的斷裂，讓數位世界出現第三種模型：設計師的被呈現模型（represented model）——也就是設計師選擇如何向使用者呈現程式的運作方式。Donald Norman 也把它簡稱為設計師模型（designer’s model）。

在軟體世界裡，被呈現模型可以（而且常常應該）跟程式實際的處理結構差很多。比如作業系統可以讓網路檔案伺服器看起來像本機磁碟；它不需要呈現那顆硬碟其實可能在幾英里外。這種「被呈現模型」在機械世界幾乎沒有普遍對應物。三種模型的關係如圖 21 所示。

一般來說，被呈現模型越接近使用者心智模型，使用者就越覺得軟體好學、好用。相反地，如果被呈現模型太貼近實作模型，通常會大幅降低使用者學習與使用程式的能力——因為幾乎總是如此：使用者對自己任務的心智模型，跟軟體的實作模型並不一致。

（圖 21 重點翻譯）
工程師在各種技術與商業限制下建構軟體，這形成了實作模型。使用者對自己要完成的工作、以及程式如何幫他完成的理解，是他的心智模型。設計師選擇如何向使用者呈現程式運作方式，叫做被呈現模型——而這一項是設計師最有控制力的。設計師最重要的目標之一，就是讓被呈現模型盡可能貼近使用者的心智模型，因此設計師必須非常細緻地理解目標使用者如何思考他們用軟體做的工作。

我們的心智模型往往比現實更簡化；所以如果我們做出比實作模型更簡化的被呈現模型，就能幫使用者更好理解。比如踩車子的煞車踏板，你腦中可能浮現「推動一個拉桿去摩擦輪子讓車慢下來」。但實際機構包含液壓缸、管路、金屬來令片夾住打孔的碟盤……我們會把這些全部簡化掉，建立一個更有效、但不那麼精確的心智模型。在軟體裡也是一樣：我們想像試算表在拖動捲軸時，是把新的格子「捲」進視窗裡；其實根本不是。外面並沒有一張「格子紙」，只有緊密的資料結構、各種指標連結，程式即時合成新的影像顯示出來。

理解軟體「真的怎麼運作」確實能幫助使用，但通常代價很高。電腦能幫人類的一個重要方式，就是把複雜流程與情境，呈現成一張簡單的臉。因此，符合使用者心智模型的介面，遠比「只是反映實作模型」的介面更好。

> 反映技術（較差） → 更反映使用者願景（較好）
> 實作模型 → 被呈現模型 → 心智模型



 設計原則

使用者介面應該建立在使用者的心智模型上，而不是建立在實作模型上。

在 Adobe Photoshop 裡，使用者可以用一個叫 Variations 的功能調整色彩平衡與亮度。它不是提供數字欄位讓你輸入色彩數值（那是實作模型），而是顯示一組縮圖，每張縮圖都有不同的色彩平衡（見圖 22）。使用者只要點選最接近自己想要效果的那張圖。這個介面更貼近心智模型，因為使用者（多半是視覺設計師）思考的是「圖片看起來怎樣」，而不是抽象的數字。

（圖 22 圖說）
Photoshop 的 Variations 是很棒的例子：它用一組縮圖呈現不同的色彩平衡與亮度（可調整增量），使用者點選最符合期望的縮圖；那張就變成新的預設，再生成更多變化縮圖。這套介面符合設計師追求「某種視覺效果」的心智模型，而不是一串抽象數值。

如果軟體的被呈現模型緊貼使用者心智模型，它就能用一個清楚的認知框架，讓使用者一眼看出如何達成目標與需求，並移除介面裡不必要的複雜性。

目標導向的互動應該反映使用者的心智模型。

使用者的心智模型不一定要「真實」或「精確」，但必須能讓他有效完成工作。比如多數不懂技術的使用者會覺得「螢幕就是電腦的核心」，這很自然：他每天盯的就是螢幕，也是在螢幕上看到電腦在做什麼。你跟他說電腦其實是桌下黑盒子裡那顆矽晶片，他大概只會聳肩——因為對他毫無意義。CPU 不是螢幕，這在技術上更正確，但並不會幫他更好思考「我怎麼跟電腦互動」。



 多數軟體其實都在迎合實作模型（Most Software Conforms to Implementation Models）

設計一套反映實作模型的軟體是比較容易的。從開發者角度看：每個功能一個按鈕、每個資料輸入一個欄位、每個交易步驟一頁、每個程式模組一個對話框——都很合邏輯。但這些雖然忠實呈現工程結構，卻很難提供使用者一套連貫的機制去達成目標。最後做出來的東西會讓使用者疏離與困惑，就像 Terry Gilliam 的電影《Brazil》裡那種反烏托邦場景：到處是外露管線（裡面也有很多諷刺、很慘的介面例子）。

 設計原則

由工程師設計的介面往往會跟著實作模型走。

工程師非常清楚軟體怎麼運作，所以他們設計出的被呈現模型，常常跟實作模型高度一致。對工程師來說，這很合理、很真實、很精準；但對使用者來說，它不太好懂，也不太有效。大多數使用者其實不在乎程式到底怎麼被實作。

一個很典型「迎合實作模型」的數位產品是：常見的「組合式家庭劇院」。使用者得知道每個元件怎麼接線，才切得出「看 DVD」或「看有線電視」。很多產品要求使用者切換影像來源，甚至要在多支遙控器之間換來換去，才能完成「看電視」這種基本需求。某些新產品採用更貼近心智模型的做法：遙控器記住元件配置，使用者只要選「看電視」，遙控器就自動對電視、機上盒、DVD、環繞音響送出正確指令，不需要使用者知道背後發生什麼。

就連 Windows 介面有時也會滑回實作模型：你在同一顆硬碟上把檔案從一個資料夾拖到另一個資料夾，它會被視為「移動（MOVE）」——檔案從舊資料夾移除、加到新資料夾，這很貼近使用者心智模型。但如果你把檔案從 C 槽拖到 D 槽，它卻被視為「複製（COPY）」——檔案被加到新位置，但舊位置不會移除。這個行為其實根植於實作模型：同一顆硬碟內移動檔案，作業系統只是在磁碟目錄表裡重新指向，並沒有真的刪除、重寫檔案；但跨到另一顆實體硬碟，就必須把資料實際複製過去。若要符合使用者心智模型，它其實應該在複製完成後刪掉原檔——即便這違背了實作模型的直覺。

這種「兩個看起來很像的動作，電腦卻給出不一致反應」很容易讓使用者產生顯著的認知失調（因為現實出現互相矛盾的兩種圖像），進而讓這個互動變得難學。使用者若要穩定達成結果，他就必須理解：電腦的行為其實取決於儲存裝置的物理特性。

而且把「跨磁碟拖曳」當成 COPY 有時又是好事，特別是把檔案從硬碟複製到 USB 隨身碟這種可移除媒體時。所以很多人沒意識到：這其實是實作模型帶來的不一致副作用。當電腦走向成熟，邏輯磁碟不再只是「實體硬碟」時，這些副作用就不再有用，反而會變得惱人，因為我們得背每種磁碟類型的怪脾氣。



 數學式思考容易把介面拉進實作模型（Mathematical thinking leads to implementation model interfaces）

互動設計師必須替使用者擋掉實作模型。某個技術很適合用來建構軟體，不代表它也適合當作使用者的心智模型。就像你的車是用焊接金屬零件做出來的，也不代表你得會拿焊槍才能開車。

軟體用來表示與操作資訊的大多資料結構與演算法，都是建立在數學算法上的邏輯工具。所有程式設計師都很熟這些工具，比如遞迴、階層式資料結構、多執行緒。問題出在：當介面試圖「忠實呈現」遞迴、階層資料或多執行緒這些概念時。

對程式設計師來說，數學式思考是一個特別容易掉進去的實作模型陷阱：他們用數學方式解問題，所以自然覺得也可以用這些數學模型來發明使用者介面。但事實完全相反。

 設計原則

使用者不懂布林邏輯（Boolean logic）。

例如，程式設計師工具箱裡最耐用也最有用的工具之一是布林代數。它用一套精簡數學系統描述電腦內部嚴格「開／關」的世界。主要運算只有兩個：AND 與 OR。問題是，英文裡也有 and 與 or，但非程式人員通常把它們理解成跟布林 AND/OR 幾乎相反的意思。當程式用布林符號跟使用者溝通，就等著被誤解。

這個問題常出現在查資料庫。假設我們要從員工資料中找出住在亞利桑那州的員工，以及住在德州的員工。用英文對人說，你會說：「找出在 Arizona 和 Texas 的員工。」但對資料庫用布林正確表達，應該是：「找出在 Arizona OR Texas 的員工。」因為沒有人同時住在兩州；所以在布林邏輯裡說「Arizona AND Texas」幾乎必然找不到任何人。

任何用布林方式跟使用者互動的應用程式，注定會有嚴重的介面問題。你期待使用者去突破這種混亂是不合理的。他們已經很熟英文了，為什麼還要用一種陌生語言來表達——更煩的是，這語言還把關鍵字重新定義。



 機械時代 vs 資訊時代的被呈現模型（MechanicalAge versus InformationAge Represented Models）

我們正經歷一場驚人的轉變：從工業的、機械的實體物件時代，走向數位的、資訊物件時代。這才剛開始，而且速度正在快速加劇。社會因工業化產生的劇變，很可能都會被資訊時代帶來的劇變比下去。

 機械時代的表徵（MechanicalAge representations）

人在面對新的、不確定的時代時，很自然會把熟悉的舊時代語言與想像帶進來。工業革命的歷史告訴我們：新技術的成果一開始常只能用舊技術的語言來描述。比如我們曾把火車頭叫做「鐵馬」，把汽車叫做「無馬馬車」。不幸的是，這種語言與想像對我們思考的影響，比我們願意承認的還大。

所以我們也很自然會在新環境裡使用舊表徵。有時這樣做是合理的，因為功能相同，即便底層技術不同。例如，把打字機的打字流程搬到電腦上的文書處理，這就是把一個常見任務用「機械時代」的表徵呈現。打字機用金屬定位鍵讓滑台快速移動到某一欄位；這種由技術自然產生的流程叫 tabbing（定位／跳格）。文書處理器也有 tab，因為功能一樣：不管你在紙上還是在螢幕影像上，你都需要快速跳到某個固定縮排位置。

但有時機械時代的表徵不應該原封不動搬到數位世界。我們不會用韁繩或舵柄來開車，雖然早期汽車曾試過。花了很多年才發展出適合汽車的方向盤操作習慣。同樣地，在文書處理器裡，我們不需要寫滿一頁就「換一張空白紙」；文件可以連續捲動，並用視覺標記表示換頁。

 新技術需要新表徵（New technology demands new representations）

有些任務、流程、概念，甚至目標，純粹因為新技術第一次讓它們成為可能才出現。在此之前它們沒有存在理由，也就不可能被事先想像出來。比如電話剛被發明時，它也被宣傳成可用來廣播音樂與新聞，但最後真正普及、被大量發展的是「個人溝通」。當時沒有人會想像：電話會變成人人隨身攜帶、放在口袋包包裡的個人物件，還會在劇院演出中途刺耳地響起。

用機械時代的思維，我們一開始很難看見適合資訊時代的表徵。很多軟體產品真正的優勢，常要等到擁有大量使用者後才變得清晰。比如 email 的真正優勢不只是「比郵件快」（機械時代觀點），而是它促進現代企業組織的扁平化與民主化（資訊時代優勢）。Web 的真正優勢也不只是更便宜、更有效率的溝通與分發（機械時代觀點），而是形成虛擬社群——這個資訊時代優勢往往要等它真的出現、被我們握住後才被看見。因為我們很難預見數位產品會怎麼被使用，所以常過度依賴過去機械時代的表徵。

 機械時代表徵會拉低互動品質（MechanicalAge representations degrade user interaction）

當我們把熟悉的機械時代表徵搬到電腦上，就會遇到問題。簡單說：機械時代的流程與表徵，往往會拉低資訊時代產品的互動品質。很多機械流程用手做反而比用電腦做更容易。比如用電腦打一個信封地址，跟直接用筆寫相比，前置成本高很多（雖然可能更整齊）。只有在大量批次自動化時才變得划算——例如你要寄 500 個信封。

再例如電腦上的聯絡人清單：如果它忠實地畫成一本小小的活頁本，反而會比實體通訊錄更複雜、更不方便、更難用。實體通訊錄通常按姓氏字母排序；但如果你想按名字找人呢？機械物件幫不上忙，你得手動掃頁。螢幕上那個忠實複製版也一樣：它也不能按名字搜尋。更糟的是，在電腦螢幕上，你還失去紙本書提供的許多微妙線索（像折角、鉛筆註記）。同時捲軸、對話框又比翻頁更難操作、更難想像、更難理解。

 設計原則

不要在沒有「資訊時代增強」的情況下，直接複製機械時代的物件到使用者介面裡。

真實世界的機械系統有其媒介的優缺點（例如紙筆）。軟體有完全不同的一組優缺點；但當你不加改造就複製機械表徵時，你會把「舊媒介的弱點」和「新媒介的弱點」疊在一起。在通訊錄例子裡，電腦其實很容易按名字搜尋，但因為你用跟機械物件一樣的方式存放名字，你等於自我剝奪了新的搜尋方式：你限制了資訊媒介可能提供的能力，又沒拿回紙本媒介原本的好處。

當設計師用機械時代表徵來指引設計，他就會被遮蔽，看不到電腦其實能以更好（雖然不同）的方式提供更強的資訊管理。機械時代表徵在介面裡常作為隱喻，反而會不自然地限制設計。關於介面隱喻依賴的陷阱，可參考第 13 章。



 改良機械時代表徵：一個例子（Improving on MechanicalAge representations: An example）

新技術不只會帶來新概念，也能延伸與強化舊概念。設計師可以透過「更新後的表徵」，把新技術的力量用在使用者身上。

例如行事曆：在非數位世界，行事曆是紙做的，通常是一頁一個月。這是基於紙張大小、資料夾、公事包、桌抽等限制下的合理折衷。

有視覺化行事曆的程式非常常見，而且幾乎都一次只顯示一個月。就算像 Outlook 那樣能顯示多個月，也幾乎都是以「一個月一塊」的方式切割呈現。為什麼？

紙本行事曆一次一個月，是因為紙張大小限制，而「月」是很方便的分段點。電腦螢幕其實不受這種限制，但多數設計師仍忠實複製機械物件（見圖 23）。在電腦上，行事曆完全可以像圖 24 那樣，變成連續可捲動的日／週／月序列。要排「8 月 28 日到 9 月 4 日」的行程，如果週是連續的、而不是被任意的月份切開，就會容易得多。

同樣地，數位行事曆的格線大小幾乎永遠固定。為什麼不能像試算表一樣，讓「天的欄寬」或「週的列高」可調？你當然會想調整週末大小，好反映它相對於平日的重要性。如果你是商務人士，你的工作週需要比度假週更大的顯示空間。這些操作習慣跟試算表一樣熟悉——也就是說，很普遍——但機械時代表徵根深蒂固，以至於我們很少看到軟體廠商偏離它。

（圖 23 圖說）
行事曆太熟悉了，我們很少停下來用資訊時代的思維重新看它在螢幕上的設計。行事曆原本是為了堆疊紙張而設計，不是為了互動式數位顯示。你會怎麼重新設計它？行事曆有哪些部分其實是舊平台（機械時代）的產物？

（圖 24 圖說）
捲動對電腦使用者是非常熟悉的操作習慣。那為什麼不把「一頁一個月」的行事曆，改成可捲動的表徵讓它更好？這個「永續行事曆」能做舊行事曆能做的一切，還解決了跨月排程這個機械表徵的老問題。不要因為習慣，就把舊限制拖到新平台上。你還能想到哪些改進？

圖 23 的設計師可能把行事曆當成「神聖不可改」的物件。更令人意外的是：大多數時間管理軟體在內部（也就是實作模型）其實是把時間當作連續體處理，但在使用者介面（被呈現模型）裡卻把它切成離散的月份！

有人可能反駁：一頁一個月比較好，因為對使用者更熟悉、好辨認。但新模型其實沒那麼不同，只是讓使用者能輕鬆做到以前不容易做到的事——跨月排程。人們並不難適應更有用、更新的熟悉系統表徵。

 設計原則

重大的改變必須帶來顯著更好的結果。

在個人資訊管理（PIM）與行程軟體裡，那些紙本風格的行事曆，正默默證明語言如何影響設計：如果我們依賴機械時代的詞彙，我們就會做出機械時代的軟體。更好的軟體應該建立在資訊時代的思維之上。
